{"version":3,"file":"index.cjs.js","sources":["../src/File.ts","../src/Watcher.ts","../src/Defiler.ts"],"sourcesContent":["import * as fs from 'fs';\n\nexport default class File {\n\t// path of file\n\tprivate _path: string = null;\n\t// cached dir\n\tprivate _dir: string = null;\n\t// cached filename\n\tprivate _filename: string = null;\n\t// cached ext\n\tprivate _ext: string = null;\n\t// stats of file\n\tstats: fs.Stats = null;\n\t// encoding\n\tprivate _enc: BufferEncoding = 'utf8';\n\t// Buffer of file contents\n\tprivate _bytes: Buffer = null;\n\t// string of file contents\n\tprivate _text: string = null;\n\n\tget path(): string {\n\t\treturn this._path;\n\t}\n\n\tset path(path: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\tthrow new TypeError('file.path must be a string');\n\t\t}\n\t\tif (this._path !== path) {\n\t\t\tthis._path = path;\n\t\t\tthis._dir = this._filename = this._ext = null;\n\t\t}\n\t}\n\n\tget dir(): string {\n\t\tif (this._dir == null) {\n\t\t\tconst p = this._path.lastIndexOf('/');\n\t\t\tthis._dir = p > -1 ? this._path.slice(0, p) : '';\n\t\t}\n\t\treturn this._dir;\n\t}\n\n\tset dir(dir: string) {\n\t\tif (typeof dir !== 'string') {\n\t\t\tthrow new TypeError('file.dir must be a string');\n\t\t}\n\t\tthis.path = (dir ? dir + '/' : '') + this.filename;\n\t}\n\n\tget filename(): string {\n\t\tif (this._filename == null) {\n\t\t\tconst p = this._path.lastIndexOf('/');\n\t\t\tthis._filename = p > -1 ? this._path.slice(p + 1) : this._path;\n\t\t}\n\t\treturn this._filename;\n\t}\n\n\tset filename(filename) {\n\t\tif (typeof filename !== 'string') {\n\t\t\tthrow new TypeError('file.filename must be a string');\n\t\t}\n\t\tconst old = this.filename;\n\t\tthis.path = (old ? this._path.slice(0, -old.length) : this._path) + filename;\n\t}\n\n\tget ext(): string {\n\t\tif (this._ext == null) {\n\t\t\tconst p1 = this._path.lastIndexOf('.');\n\t\t\tconst p2 = this._path.lastIndexOf('/');\n\t\t\tthis._ext = p1 > -1 && p1 > p2 ? this._path.slice(p1) : '';\n\t\t}\n\t\treturn this._ext;\n\t}\n\n\tset ext(ext: string) {\n\t\tif (typeof ext !== 'string') {\n\t\t\tthrow new TypeError('file.ext must be a string');\n\t\t}\n\t\tconst old = this.ext;\n\t\tthis.path = (old ? this._path.slice(0, -old.length) : this._path) + ext;\n\t}\n\n\tget enc(): BufferEncoding {\n\t\treturn this._enc;\n\t}\n\n\tset enc(enc: BufferEncoding) {\n\t\tif (!Buffer.isEncoding(enc)) {\n\t\t\tthrow new TypeError('file.enc must be a supported encoding');\n\t\t}\n\t\tthis._enc = enc;\n\t}\n\n\tget bytes(): Buffer {\n\t\treturn this._bytes == null && this._text != null ? (this._bytes = Buffer.from(this._text, this._enc)) : this._bytes;\n\t}\n\n\tset bytes(bytes: Buffer) {\n\t\tif (bytes != null && !Buffer.isBuffer(bytes)) {\n\t\t\tthrow new TypeError('file.bytes must be a Buffer or null');\n\t\t}\n\t\tthis._bytes = bytes;\n\t\tthis._text = null;\n\t}\n\n\tget text(): string {\n\t\treturn this._text == null && this._bytes != null ? (this._text = this._bytes.toString(this._enc)) : this._text;\n\t}\n\n\tset text(text: string) {\n\t\tif (text != null && typeof text !== 'string') {\n\t\t\tthrow new TypeError('file.text must be a string or null');\n\t\t}\n\t\tthis._text = text;\n\t\tthis._bytes = null;\n\t}\n}\n","import * as EventEmitter from 'events';\nimport * as fs from 'fs';\n\nexport default class Watcher extends EventEmitter {\n\tdir: string;\n\tfilter: (file: { path: string; stats: fs.Stats }) => boolean;\n\twatch: boolean;\n\tdebounce: number;\n\t// paths of all directories -> FSWatcher instances\n\tprivate _watchers = new Map<string, fs.FSWatcher>();\n\t// paths of all files -> file stats\n\tprivate _stats = new Map<string, fs.Stats>();\n\t// paths of files with pending debounced events -> setTimeout timer ids\n\tprivate _timeouts = new Map<string, NodeJS.Timer>();\n\t// queue of pending FSWatcher events to handle\n\tprivate _queue: string[] = [];\n\t// whether some FSWatcher event is currently already in the process of being handled\n\tprivate _is_processing: boolean = false;\n\n\tconstructor(data: object /* = { dir, filter, watch, debounce } */) {\n\t\tsuper();\n\t\tObject.assign(this, data);\n\t}\n\n\t// recurse directory, get stats, set up FSWatcher instances\n\t// returns array of { path, stats }\n\tasync init(): Promise<{ path: string; stats: fs.Stats }[]> {\n\t\tawait this._recurse(this.dir);\n\t\treturn [...this._stats.entries()].map(([path, stats]) => ({ path, stats }));\n\t}\n\n\t// recurse a given directory\n\tprivate async _recurse(full: string): Promise<void> {\n\t\tconst path = full.slice(this.dir.length + 1);\n\t\tconst stats = await fs.promises.stat(full);\n\t\tif (this.filter && !(await this.filter({ path, stats }))) {\n\t\t\treturn;\n\t\t}\n\t\tif (stats.isFile()) {\n\t\t\tthis._stats.set(path, stats);\n\t\t} else if (stats.isDirectory()) {\n\t\t\tif (this.watch) {\n\t\t\t\tthis._watchers.set(path, fs.watch(full, this._handle.bind(this, full)));\n\t\t\t}\n\t\t\tawait Promise.all((await fs.promises.readdir(full)).map((sub) => this._recurse(full + '/' + sub)));\n\t\t}\n\t}\n\n\t// handle FSWatcher event for given directory\n\tprivate _handle(dir: string, event: string, file: string): void {\n\t\tconst full = dir + '/' + file;\n\t\tif (this._timeouts.has(full)) {\n\t\t\tclearTimeout(this._timeouts.get(full));\n\t\t}\n\t\tthis._timeouts.set(\n\t\t\tfull,\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis._timeouts.delete(full);\n\t\t\t\tthis._enqueue(full);\n\t\t\t}, this.debounce),\n\t\t);\n\t}\n\n\t// add an FSWatcher event to the queue, and handle queued events\n\tprivate async _enqueue(full: string): Promise<void> {\n\t\tthis._queue.push(full);\n\t\tif (this._is_processing) {\n\t\t\treturn;\n\t\t}\n\t\tthis._is_processing = true;\n\t\twhile (this._queue.length) {\n\t\t\tconst full = this._queue.shift();\n\t\t\tconst path = full.slice(this.dir.length + 1);\n\t\t\ttry {\n\t\t\t\tconst stats = await fs.promises.stat(full);\n\t\t\t\tif (this.filter && !(await this.filter({ path, stats }))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (stats.isFile()) {\n\t\t\t\t\t// note the new/changed file\n\t\t\t\t\tthis._stats.set(path, stats);\n\t\t\t\t\tthis.emit('', { event: '+', path, stats });\n\t\t\t\t} else if (stats.isDirectory() && !this._watchers.has(path)) {\n\t\t\t\t\t// note the new directory: start watching it, and report any files in it\n\t\t\t\t\tawait this._recurse(full);\n\t\t\t\t\tfor (const [new_path, stats] of this._stats.entries()) {\n\t\t\t\t\t\tif (new_path.startsWith(path + '/')) {\n\t\t\t\t\t\t\tthis.emit('', { event: '+', path: new_path, stats });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// probably this was a deleted file/directory\n\t\t\t\tif (this._stats.has(path)) {\n\t\t\t\t\t// note the deleted file\n\t\t\t\t\tthis._stats.delete(path);\n\t\t\t\t\tthis.emit('', { event: '-', path });\n\t\t\t\t} else if (this._watchers.has(path)) {\n\t\t\t\t\t// note the deleted directory: stop watching it, and report any files that were in it\n\t\t\t\t\tfor (const old of this._watchers.keys()) {\n\t\t\t\t\t\tif (old === path || old.startsWith(path + '/')) {\n\t\t\t\t\t\t\tthis._watchers.get(old).close();\n\t\t\t\t\t\t\tthis._watchers.delete(old);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const old of this._stats.keys()) {\n\t\t\t\t\t\tif (old.startsWith(path + '/')) {\n\t\t\t\t\t\t\tthis._stats.delete(old);\n\t\t\t\t\t\t\tthis.emit('', { event: '-', path: old });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._is_processing = false;\n\t}\n}\n\nexport interface WatcherEvent {\n\tevent: string;\n\tpath: string;\n\tstats?: fs.Stats;\n}\n","import { AsyncLocalStorage } from 'async_hooks';\nimport * as fs from 'fs';\nimport { resolve } from 'path';\n\nimport File from './File';\nimport Watcher, { WatcherEvent } from './Watcher';\n\nexport default class Defiler {\n\t// set of original paths for all physical files\n\tpaths = new Set<string>();\n\t// original paths -> original file data for all physical files ({ path, stats, bytes, enc })\n\tprivate _orig_data = new Map<string, FileData>();\n\t// original paths -> transformed files for all physical and virtual files\n\tfiles = new Map<string, File>();\n\t// Before, During, or After exec has been called\n\tprivate _status = Status.Before;\n\t// AsyncLocalStorage instance for tracking call stack contexts and dependencies\n\tprivate _context = new AsyncLocalStorage<Name>();\n\t// Watcher instances\n\tprivate _watchers: WatcherData[];\n\t// the transform to run on all files\n\tprivate _transform: Transform;\n\t// registered generators\n\tprivate _generators: Generator[];\n\t// (base, path) => path resolver function, used in defiler.get and defiler.add from transform\n\tprivate _resolver: Resolver;\n\t// handler to call when errors occur\n\tprivate _onerror: OnError;\n\t// original paths of all files currently undergoing transformation and symbols of all generators currently running\n\tprivate _active = new Set<Name>();\n\t// original paths -> { promise, resolve, paths } objects for when awaited files become available\n\tprivate _when_found = new Map<string | Filter, WhenFound>();\n\t// array of [dependent, dependency] pairs, specifying changes to which files should trigger re-processing which other files\n\tprivate _deps: [Name, string | Filter][] = [];\n\t// queue of pending Watcher events to handle\n\tprivate _queue: [WatcherData, WatcherEvent][] = [];\n\t// whether some Watcher event is currently already in the process of being handled\n\tprivate _is_processing = false;\n\t// end the current wave\n\tprivate _end_wave: () => void = null;\n\n\tconstructor(...args: any[]) {\n\t\tconst { transform, generators = [], resolver, onerror } = <DefilerData>args.pop();\n\t\tif (typeof transform !== 'function') {\n\t\t\tthrow new TypeError('defiler: transform must be a function');\n\t\t}\n\t\tif (!Array.isArray(generators) || generators.some((generator) => typeof generator !== 'function')) {\n\t\t\tthrow new TypeError('defiler: generators must be an array of functions');\n\t\t}\n\t\tif (resolver && typeof resolver !== 'function') {\n\t\t\tthrow new TypeError('defiler: resolver must be a function');\n\t\t}\n\t\tif (onerror && typeof onerror !== 'function') {\n\t\t\tthrow new TypeError('defiler: onerror must be a function');\n\t\t}\n\t\tthis._watchers = args.map(({ dir, filter, read = true, enc = 'utf8', pre, watch = true, debounce = 10 }) => {\n\t\t\tif (typeof dir !== 'string') {\n\t\t\t\tthrow new TypeError('defiler: dir must be a string');\n\t\t\t}\n\t\t\tif (filter && typeof filter !== 'function') {\n\t\t\t\tthrow new TypeError('defiler: filter must be a function');\n\t\t\t}\n\t\t\tif (typeof read !== 'boolean' && typeof read !== 'function') {\n\t\t\t\tthrow new TypeError('defiler: read must be a boolean or a function');\n\t\t\t}\n\t\t\tif (!Buffer.isEncoding(enc) && typeof enc !== 'function') {\n\t\t\t\tthrow new TypeError('defiler: enc must be a supported encoding or a function');\n\t\t\t}\n\t\t\tif (pre && typeof pre !== 'function') {\n\t\t\t\tthrow new TypeError('defiler: pre must be a function');\n\t\t\t}\n\t\t\tif (typeof watch !== 'boolean') {\n\t\t\t\tthrow new TypeError('defiler: watch must be a boolean');\n\t\t\t}\n\t\t\tif (typeof debounce !== 'number') {\n\t\t\t\tthrow new TypeError('defiler: debounce must be a number');\n\t\t\t}\n\t\t\treturn <WatcherData>new Watcher({ dir, filter, read, enc, pre, watch, debounce });\n\t\t});\n\t\tthis._transform = transform;\n\t\tthis._generators = generators;\n\t\tthis._resolver = resolver;\n\t\tthis._onerror = onerror;\n\t}\n\n\t// execute everything, and return a promise that resolves when the first wave of processing is complete\n\tasync exec(): Promise<void> {\n\t\tif (this._status !== Status.Before) {\n\t\t\tthrow new Error('defiler.exec: cannot call more than once');\n\t\t}\n\t\tthis._status = Status.During;\n\t\tthis._is_processing = true;\n\t\tconst done = this._start_wave();\n\t\t// init the Watcher instances\n\t\tconst files: [WatcherData, string, { path: string; stats: fs.Stats }][] = [];\n\t\tawait Promise.all(\n\t\t\tthis._watchers.map(async (watcher) => {\n\t\t\t\twatcher.dir = resolve(watcher.dir);\n\t\t\t\twatcher.on('', (event) => this._enqueue(watcher, event));\n\t\t\t\t// note that all files are pending transformation\n\t\t\t\tawait Promise.all(\n\t\t\t\t\t(await watcher.init()).map(async (file) => {\n\t\t\t\t\t\tconst { path } = file;\n\t\t\t\t\t\tif (watcher.pre) {\n\t\t\t\t\t\t\tawait watcher.pre(file);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.paths.add(file.path);\n\t\t\t\t\t\tthis._active.add(file.path);\n\t\t\t\t\t\tfiles.push([watcher, path, file]);\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t\tfor (const generator of this._generators) {\n\t\t\tthis._active.add(generator);\n\t\t}\n\t\t// process each physical file\n\t\tfor (const [watcher, path, file] of files) {\n\t\t\tthis._process_physical_file(watcher, path, file);\n\t\t}\n\t\t// process each generator\n\t\tfor (const generator of this._generators) {\n\t\t\tthis._process_generator(generator);\n\t\t}\n\t\t// wait and finish up\n\t\tawait done;\n\t\tthis._status = Status.After;\n\t\tthis._is_processing = false;\n\t\tif (this._watchers.some((watcher) => watcher.watch)) {\n\t\t\tthis._enqueue();\n\t\t}\n\t}\n\n\t// wait for a file to be available and retrieve it, marking dependencies as appropriate\n\tasync get(path: string): Promise<File>;\n\tasync get(paths: string[]): Promise<File[]>;\n\tasync get(filter: Filter): Promise<File[]>;\n\tasync get(_: any): Promise<any> {\n\t\tif (typeof _ === 'string') {\n\t\t\t_ = this.resolve(_);\n\t\t}\n\t\tif (Array.isArray(_)) {\n\t\t\treturn Promise.all(_.map((path) => this.get(path)));\n\t\t}\n\t\tif (typeof _ !== 'string' && typeof _ !== 'function') {\n\t\t\tthrow new TypeError('defiler.get: argument must be a string, an array, or a function');\n\t\t}\n\t\tconst current = this._context.getStore();\n\t\tif (current) {\n\t\t\tthis._deps.push([current, _]);\n\t\t}\n\t\tif (this._status === Status.During && current && (typeof _ === 'function' || !this.files.has(_))) {\n\t\t\tif (this._when_found.has(_)) {\n\t\t\t\tconst { promise, paths } = this._when_found.get(_);\n\t\t\t\tpaths.push(current);\n\t\t\t\tawait promise;\n\t\t\t} else {\n\t\t\t\tlet resolve;\n\t\t\t\tconst promise = new Promise<void>((res) => (resolve = res));\n\t\t\t\tthis._when_found.set(_, { promise, resolve, paths: [current] });\n\t\t\t\tawait promise;\n\t\t\t}\n\t\t}\n\t\treturn typeof _ === 'function' ? this.get([...this.files.keys()].filter(_).sort()) : this.files.get(_);\n\t}\n\n\t// add a new virtual file\n\tadd(file: FileData): Promise<void> {\n\t\tif (this._status === Status.Before) {\n\t\t\tthrow new Error('defiler.add: cannot call before calling exec');\n\t\t}\n\t\tif (typeof file !== 'object') {\n\t\t\tthrow new TypeError('defiler.add: file must be an object');\n\t\t}\n\t\tfile.path = this.resolve(file.path);\n\t\tthis._orig_data.set(file.path, file);\n\t\treturn this._process_file(file, 'add');\n\t}\n\n\t// resolve a given path from the file currently being transformed\n\tresolve(path: string): string {\n\t\tif (this._resolver) {\n\t\t\tconst current = this._context.getStore();\n\t\t\tif (typeof current === 'string') {\n\t\t\t\treturn this._resolver(current, path);\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}\n\n\t// private methods\n\n\t// return a Promise that we will resolve at the end of this wave, and save its resolver\n\tprivate _start_wave(): Promise<void> {\n\t\treturn new Promise((res) => (this._end_wave = res));\n\t}\n\n\t// add a Watcher event to the queue, and handle queued events\n\tprivate async _enqueue(watcher?: WatcherData, event?: WatcherEvent): Promise<void> {\n\t\tif (event) {\n\t\t\tthis._queue.push([watcher, event]);\n\t\t}\n\t\tif (this._is_processing) {\n\t\t\treturn;\n\t\t}\n\t\tthis._is_processing = true;\n\t\twhile (this._queue.length) {\n\t\t\tconst done = this._start_wave();\n\t\t\tconst [watcher, { event, path, stats }] = this._queue.shift();\n\t\t\tconst file = { path, stats };\n\t\t\tif (watcher.pre) {\n\t\t\t\tawait watcher.pre(file);\n\t\t\t}\n\t\t\tif (event === '+') {\n\t\t\t\tthis._process_physical_file(watcher, path, file);\n\t\t\t} else if (event === '-') {\n\t\t\t\tconst { path } = file;\n\t\t\t\tconst old_file = this.files.get(path);\n\t\t\t\tthis.paths.delete(path);\n\t\t\t\tthis._orig_data.delete(path);\n\t\t\t\tthis.files.delete(path);\n\t\t\t\tawait this._call_transform(old_file, 'delete');\n\t\t\t\tthis._process_dependents(path);\n\t\t\t}\n\t\t\tawait done;\n\t\t}\n\t\tthis._is_processing = false;\n\t}\n\n\t// create a file object for a physical file and process it\n\tprivate async _process_physical_file({ dir, read, enc }: WatcherData, path: string, file: FileData): Promise<void> {\n\t\tif (typeof read === 'function') {\n\t\t\tread = await read({ path, stats: file.stats });\n\t\t}\n\t\tif (read) {\n\t\t\tfile.bytes = await fs.promises.readFile(dir + '/' + path);\n\t\t}\n\t\tif (typeof enc === 'function') {\n\t\t\tenc = await enc({ path, stats: file.stats, bytes: file.bytes });\n\t\t}\n\t\tfile.enc = enc;\n\t\tthis.paths.add(file.path);\n\t\tthis._orig_data.set(file.path, file);\n\t\tawait this._process_file(file, 'read');\n\t}\n\n\t// transform a file, store it, and process dependents\n\tprivate async _process_file(data: FileData, event: string): Promise<void> {\n\t\tconst file: File = Object.assign(new File(), data);\n\t\tconst { path } = file;\n\t\tthis._active.add(path);\n\t\tawait this._call_transform(file, event);\n\t\tthis.files.set(path, file);\n\t\tif (this._status === Status.During) {\n\t\t\tthis._mark_found(path);\n\t\t} else {\n\t\t\tthis._process_dependents(path);\n\t\t}\n\t\tthis._active.delete(path);\n\t\tthis._check_wave();\n\t}\n\n\t// call the transform on a file with the given event string, and handle errors\n\tprivate async _call_transform(file: File, event: string): Promise<void> {\n\t\ttry {\n\t\t\tawait this._context.run(file.path, () => this._transform({ file, event }));\n\t\t} catch (error) {\n\t\t\tif (this._onerror) {\n\t\t\t\tthis._onerror({ file, event, error });\n\t\t\t}\n\t\t}\n\t}\n\n\t// run the generator given by the symbol\n\tprivate async _process_generator(generator: Generator): Promise<void> {\n\t\tthis._active.add(generator);\n\t\ttry {\n\t\t\tawait this._context.run(generator, generator);\n\t\t} catch (error) {\n\t\t\tif (this._onerror) {\n\t\t\t\tthis._onerror({ generator, error });\n\t\t\t}\n\t\t}\n\t\tthis._active.delete(generator);\n\t\tthis._check_wave();\n\t}\n\n\t// re-process all files that depend on a particular path\n\tprivate _process_dependents(path: string): void {\n\t\tconst dependents = new Set<Name>();\n\t\tfor (const [dependent, dependency] of this._deps) {\n\t\t\tif (typeof dependency === 'string' ? dependency === path : dependency(path)) {\n\t\t\t\tdependents.add(dependent);\n\t\t\t}\n\t\t}\n\t\tthis._deps = this._deps.filter(([dependent]) => !dependents.has(dependent));\n\t\tfor (const dependent of dependents) {\n\t\t\tif (typeof dependent === 'function') {\n\t\t\t\tthis._process_generator(dependent);\n\t\t\t} else if (this._orig_data.has(dependent)) {\n\t\t\t\tthis._process_file(this._orig_data.get(dependent), 'retransform');\n\t\t\t}\n\t\t}\n\t\tthis._check_wave();\n\t}\n\n\t// check whether this wave is complete, and, if not, whether we need to break a deadlock\n\tprivate _check_wave(): void {\n\t\tif (!this._active.size) {\n\t\t\tthis._end_wave();\n\t\t} else if (this._status === Status.During) {\n\t\t\tconst filter_waiting = new Set<Name>();\n\t\t\tconst all_waiting = new Set<Name>();\n\t\t\tfor (const [path, { paths }] of this._when_found) {\n\t\t\t\tif (typeof path === 'function' || this._active.has(path)) {\n\t\t\t\t\tpaths.forEach((path) => filter_waiting.add(path));\n\t\t\t\t}\n\t\t\t\tpaths.forEach((path) => all_waiting.add(path));\n\t\t\t}\n\t\t\tif ([...this._active].every((path) => filter_waiting.has(path))) {\n\t\t\t\t// all pending files are currently waiting for a filter or another pending file\n\t\t\t\t// break deadlock: assume all filters have found all they're going to find\n\t\t\t\tfor (const path of this._when_found.keys()) {\n\t\t\t\t\tif (typeof path === 'function') {\n\t\t\t\t\t\tthis._mark_found(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ([...this._active].every((path) => all_waiting.has(path))) {\n\t\t\t\t// all pending files are currently waiting for one or more other files to exist\n\t\t\t\t// break deadlock: assume all files that have not appeared yet will never do so\n\t\t\t\tfor (const path of this._when_found.keys()) {\n\t\t\t\t\tif (typeof path === 'string' && !this._active.has(path)) {\n\t\t\t\t\t\tthis._mark_found(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// mark a given awaited file as being found\n\tprivate _mark_found(path: string | Filter): void {\n\t\tif (this._when_found.has(path)) {\n\t\t\tthis._when_found.get(path).resolve();\n\t\t\tthis._when_found.delete(path);\n\t\t}\n\t}\n}\n\ninterface DefilerData {\n\ttransform: Transform;\n\tgenerators?: Generator[];\n\tresolver?: Resolver;\n\tonerror?: OnError;\n}\n\ninterface FileData {\n\tpath: string;\n\t[prop: string]: any;\n}\n\ninterface Filter {\n\t(path: string): boolean;\n}\n\ninterface Generator {\n\t(): Promise<void>;\n}\n\ntype Name = string | Generator;\n\ninterface OnError {\n\t(arg: { file?: any; event?: string; generator?: Generator; error: Error }): void;\n}\n\ninterface Resolver {\n\t(base: string, path: string): string;\n}\n\nconst enum Status {\n\tBefore,\n\tDuring,\n\tAfter,\n}\n\ninterface Transform {\n\t(arg: { file: File; event: string }): Promise<void>;\n}\n\ninterface WatcherData extends Watcher {\n\tread: boolean | ((arg: { path: string; stats: fs.Stats }) => Promise<boolean>);\n\tenc: string | ((arg: { path: string; stats: fs.Stats; bytes: Buffer }) => Promise<string>);\n\tpre: (data: FileData) => Promise<void>;\n}\n\ninterface WhenFound {\n\tpromise: Promise<void>;\n\tresolve: () => void;\n\tpaths: Name[];\n}\n"],"names":["fs.promises","fs.watch","AsyncLocalStorage","resolve"],"mappings":"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"}