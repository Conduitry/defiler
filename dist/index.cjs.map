{"version":3,"file":"index.cjs","sources":["../src/File.ts","../src/Watcher.ts","../src/Defiler.ts"],"sourcesContent":["import * as fs from 'fs';\n\nexport default class File {\n\t// path of file\n\tprivate _path: string = null;\n\t// cached dir\n\tprivate _dir: string = null;\n\t// cached filename\n\tprivate _filename: string = null;\n\t// cached ext\n\tprivate _ext: string = null;\n\t// stats of file\n\tstats: fs.Stats = null;\n\t// encoding\n\tprivate _enc: BufferEncoding = 'utf8';\n\t// Buffer of file contents\n\tprivate _bytes: Buffer = null;\n\t// string of file contents\n\tprivate _text: string = null;\n\n\tget path(): string {\n\t\treturn this._path;\n\t}\n\n\tset path(path: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\tthrow new TypeError('file.path must be a string');\n\t\t}\n\t\tif (this._path !== path) {\n\t\t\tthis._path = path;\n\t\t\tthis._dir = this._filename = this._ext = null;\n\t\t}\n\t}\n\n\tget dir(): string {\n\t\tif (this._dir == null) {\n\t\t\tconst p = this._path.lastIndexOf('/');\n\t\t\tthis._dir = p > -1 ? this._path.slice(0, p) : '';\n\t\t}\n\t\treturn this._dir;\n\t}\n\n\tset dir(dir: string) {\n\t\tif (typeof dir !== 'string') {\n\t\t\tthrow new TypeError('file.dir must be a string');\n\t\t}\n\t\tthis.path = (dir ? dir + '/' : '') + this.filename;\n\t}\n\n\tget filename(): string {\n\t\tif (this._filename == null) {\n\t\t\tconst p = this._path.lastIndexOf('/');\n\t\t\tthis._filename = p > -1 ? this._path.slice(p + 1) : this._path;\n\t\t}\n\t\treturn this._filename;\n\t}\n\n\tset filename(filename) {\n\t\tif (typeof filename !== 'string') {\n\t\t\tthrow new TypeError('file.filename must be a string');\n\t\t}\n\t\tconst old = this.filename;\n\t\tthis.path = (old ? this._path.slice(0, -old.length) : this._path) + filename;\n\t}\n\n\tget ext(): string {\n\t\tif (this._ext == null) {\n\t\t\tconst p1 = this._path.lastIndexOf('.');\n\t\t\tconst p2 = this._path.lastIndexOf('/');\n\t\t\tthis._ext = p1 > -1 && p1 > p2 ? this._path.slice(p1) : '';\n\t\t}\n\t\treturn this._ext;\n\t}\n\n\tset ext(ext: string) {\n\t\tif (typeof ext !== 'string') {\n\t\t\tthrow new TypeError('file.ext must be a string');\n\t\t}\n\t\tconst old = this.ext;\n\t\tthis.path = (old ? this._path.slice(0, -old.length) : this._path) + ext;\n\t}\n\n\tget enc(): BufferEncoding {\n\t\treturn this._enc;\n\t}\n\n\tset enc(enc: BufferEncoding) {\n\t\tif (!Buffer.isEncoding(enc)) {\n\t\t\tthrow new TypeError('file.enc must be a supported encoding');\n\t\t}\n\t\tthis._enc = enc;\n\t}\n\n\tget bytes(): Buffer {\n\t\treturn this._bytes == null && this._text != null ? (this._bytes = Buffer.from(this._text, this._enc)) : this._bytes;\n\t}\n\n\tset bytes(bytes: Buffer) {\n\t\tif (bytes != null && !Buffer.isBuffer(bytes)) {\n\t\t\tthrow new TypeError('file.bytes must be a Buffer or null');\n\t\t}\n\t\tthis._bytes = bytes;\n\t\tthis._text = null;\n\t}\n\n\tget text(): string {\n\t\treturn this._text == null && this._bytes != null ? (this._text = this._bytes.toString(this._enc)) : this._text;\n\t}\n\n\tset text(text: string) {\n\t\tif (text != null && typeof text !== 'string') {\n\t\t\tthrow new TypeError('file.text must be a string or null');\n\t\t}\n\t\tthis._text = text;\n\t\tthis._bytes = null;\n\t}\n}\n","import { EventEmitter } from 'events';\nimport * as fs from 'fs';\n\nexport default class Watcher extends EventEmitter {\n\tdir: string;\n\tfilter: (file: { path: string; stats: fs.Stats }) => boolean;\n\twatch: boolean;\n\tdebounce: number;\n\t// paths of all directories -> FSWatcher instances\n\tprivate _watchers = new Map<string, fs.FSWatcher>();\n\t// paths of all files -> file stats\n\tprivate _stats = new Map<string, fs.Stats>();\n\t// paths of files with pending debounced events -> setTimeout timer ids\n\tprivate _timeouts = new Map<string, NodeJS.Timer>();\n\t// queue of pending FSWatcher events to handle\n\tprivate _queue: string[] = [];\n\t// whether some FSWatcher event is currently already in the process of being handled\n\tprivate _is_processing: boolean = false;\n\n\tconstructor(data: object /* = { dir, filter, watch, debounce } */) {\n\t\tsuper();\n\t\tObject.assign(this, data);\n\t}\n\n\t// recurse directory, get stats, set up FSWatcher instances\n\t// returns array of { path, stats }\n\tasync init(): Promise<{ path: string; stats: fs.Stats }[]> {\n\t\tawait this._recurse(this.dir);\n\t\treturn [...this._stats.entries()].map(([path, stats]) => ({ path, stats }));\n\t}\n\n\t// recurse a given directory\n\tprivate async _recurse(full: string): Promise<void> {\n\t\tconst path = full.slice(this.dir.length + 1);\n\t\tconst stats = await fs.promises.stat(full);\n\t\tif (this.filter && !(await this.filter({ path, stats }))) {\n\t\t\treturn;\n\t\t}\n\t\tif (stats.isFile()) {\n\t\t\tthis._stats.set(path, stats);\n\t\t} else if (stats.isDirectory()) {\n\t\t\tif (this.watch) {\n\t\t\t\tthis._watchers.set(path, fs.watch(full, this._handle.bind(this, full)));\n\t\t\t}\n\t\t\tawait Promise.all((await fs.promises.readdir(full)).map((sub) => this._recurse(full + '/' + sub)));\n\t\t}\n\t}\n\n\t// handle FSWatcher event for given directory\n\tprivate _handle(dir: string, event: string, file: string): void {\n\t\tconst full = dir + '/' + file;\n\t\tif (this._timeouts.has(full)) {\n\t\t\tclearTimeout(this._timeouts.get(full));\n\t\t}\n\t\tthis._timeouts.set(\n\t\t\tfull,\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis._timeouts.delete(full);\n\t\t\t\tthis._enqueue(full);\n\t\t\t}, this.debounce),\n\t\t);\n\t}\n\n\t// add an FSWatcher event to the queue, and handle queued events\n\tprivate async _enqueue(full: string): Promise<void> {\n\t\tthis._queue.push(full);\n\t\tif (this._is_processing) {\n\t\t\treturn;\n\t\t}\n\t\tthis._is_processing = true;\n\t\twhile (this._queue.length) {\n\t\t\tconst full = this._queue.shift();\n\t\t\tconst path = full.slice(this.dir.length + 1);\n\t\t\ttry {\n\t\t\t\tconst stats = await fs.promises.stat(full);\n\t\t\t\tif (this.filter && !(await this.filter({ path, stats }))) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (stats.isFile()) {\n\t\t\t\t\t// note the new/changed file\n\t\t\t\t\tthis._stats.set(path, stats);\n\t\t\t\t\tthis.emit('', { event: '+', path, stats });\n\t\t\t\t} else if (stats.isDirectory() && !this._watchers.has(path)) {\n\t\t\t\t\t// note the new directory: start watching it, and report any files in it\n\t\t\t\t\tawait this._recurse(full);\n\t\t\t\t\tfor (const [new_path, stats] of this._stats.entries()) {\n\t\t\t\t\t\tif (new_path.startsWith(path + '/')) {\n\t\t\t\t\t\t\tthis.emit('', { event: '+', path: new_path, stats });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// probably this was a deleted file/directory\n\t\t\t\tif (this._stats.has(path)) {\n\t\t\t\t\t// note the deleted file\n\t\t\t\t\tthis._stats.delete(path);\n\t\t\t\t\tthis.emit('', { event: '-', path });\n\t\t\t\t} else if (this._watchers.has(path)) {\n\t\t\t\t\t// note the deleted directory: stop watching it, and report any files that were in it\n\t\t\t\t\tfor (const old of this._watchers.keys()) {\n\t\t\t\t\t\tif (old === path || old.startsWith(path + '/')) {\n\t\t\t\t\t\t\tthis._watchers.get(old).close();\n\t\t\t\t\t\t\tthis._watchers.delete(old);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const old of this._stats.keys()) {\n\t\t\t\t\t\tif (old.startsWith(path + '/')) {\n\t\t\t\t\t\t\tthis._stats.delete(old);\n\t\t\t\t\t\t\tthis.emit('', { event: '-', path: old });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._is_processing = false;\n\t}\n}\n\nexport interface WatcherEvent {\n\tevent: string;\n\tpath: string;\n\tstats?: fs.Stats;\n}\n","import { AsyncLocalStorage } from 'async_hooks';\nimport * as fs from 'fs';\nimport { resolve } from 'path';\n\nimport File from './File';\nimport Watcher, { WatcherEvent } from './Watcher';\n\nexport default class Defiler {\n\t// set of original paths for all physical files\n\tpaths = new Set<string>();\n\t// original paths -> original file data for all physical files ({ path, stats, bytes, enc })\n\tprivate _orig_data = new Map<string, FileData>();\n\t// original paths -> transformed files for all physical and virtual files\n\tfiles = new Map<string, File>();\n\t// Before, During, or After exec has been called\n\tprivate _status = Status.Before;\n\t// AsyncLocalStorage instance for tracking call stack contexts and dependencies\n\tprivate _context = new AsyncLocalStorage<Name>();\n\t// Watcher instances\n\tprivate _watchers: WatcherData[];\n\t// the transform to run on all files\n\tprivate _transform: Transform;\n\t// registered generators\n\tprivate _generators: Generator[];\n\t// (base, path) => path resolver function, used in defiler.get and defiler.add from transform\n\tprivate _resolver: Resolver;\n\t// handler to call when errors occur\n\tprivate _onerror: OnError;\n\t// original paths of all files currently undergoing transformation and symbols of all generators currently running\n\tprivate _active = new Set<Name>();\n\t// original paths -> { promise, resolve, paths } objects for when awaited files become available\n\tprivate _when_found = new Map<string | Filter, WhenFound>();\n\t// array of [dependent, dependency] pairs, specifying changes to which files should trigger re-processing which other files\n\tprivate _deps: [Name, string | Filter][] = [];\n\t// queue of pending Watcher events to handle\n\tprivate _queue: [WatcherData, WatcherEvent][] = [];\n\t// whether some Watcher event is currently already in the process of being handled\n\tprivate _is_processing = false;\n\t// end the current wave\n\tprivate _end_wave: () => void = null;\n\n\tconstructor(...args: any[]) {\n\t\tconst { transform, generators = [], resolver, onerror } = <DefilerData>args.pop();\n\t\tif (typeof transform !== 'function') {\n\t\t\tthrow new TypeError('defiler: transform must be a function');\n\t\t}\n\t\tif (!Array.isArray(generators) || generators.some((generator) => typeof generator !== 'function')) {\n\t\t\tthrow new TypeError('defiler: generators must be an array of functions');\n\t\t}\n\t\tif (resolver && typeof resolver !== 'function') {\n\t\t\tthrow new TypeError('defiler: resolver must be a function');\n\t\t}\n\t\tif (onerror && typeof onerror !== 'function') {\n\t\t\tthrow new TypeError('defiler: onerror must be a function');\n\t\t}\n\t\tthis._watchers = args.map(({ dir, filter, read = true, enc = 'utf8', pre, watch = true, debounce = 10 }) => {\n\t\t\tif (typeof dir !== 'string') {\n\t\t\t\tthrow new TypeError('defiler: dir must be a string');\n\t\t\t}\n\t\t\tif (filter && typeof filter !== 'function') {\n\t\t\t\tthrow new TypeError('defiler: filter must be a function');\n\t\t\t}\n\t\t\tif (typeof read !== 'boolean' && typeof read !== 'function') {\n\t\t\t\tthrow new TypeError('defiler: read must be a boolean or a function');\n\t\t\t}\n\t\t\tif (!Buffer.isEncoding(enc) && typeof enc !== 'function') {\n\t\t\t\tthrow new TypeError('defiler: enc must be a supported encoding or a function');\n\t\t\t}\n\t\t\tif (pre && typeof pre !== 'function') {\n\t\t\t\tthrow new TypeError('defiler: pre must be a function');\n\t\t\t}\n\t\t\tif (typeof watch !== 'boolean') {\n\t\t\t\tthrow new TypeError('defiler: watch must be a boolean');\n\t\t\t}\n\t\t\tif (typeof debounce !== 'number') {\n\t\t\t\tthrow new TypeError('defiler: debounce must be a number');\n\t\t\t}\n\t\t\treturn <WatcherData>new Watcher({ dir, filter, read, enc, pre, watch, debounce });\n\t\t});\n\t\tthis._transform = transform;\n\t\tthis._generators = generators;\n\t\tthis._resolver = resolver;\n\t\tthis._onerror = onerror;\n\t}\n\n\t// execute everything, and return a promise that resolves when the first wave of processing is complete\n\tasync exec(): Promise<void> {\n\t\tif (this._status !== Status.Before) {\n\t\t\tthrow new Error('defiler.exec: cannot call more than once');\n\t\t}\n\t\tthis._status = Status.During;\n\t\tthis._is_processing = true;\n\t\tconst done = this._start_wave();\n\t\t// init the Watcher instances\n\t\tconst files: [WatcherData, string, { path: string; stats: fs.Stats }][] = [];\n\t\tawait Promise.all(\n\t\t\tthis._watchers.map(async (watcher) => {\n\t\t\t\twatcher.dir = resolve(watcher.dir);\n\t\t\t\twatcher.on('', (event) => this._enqueue(watcher, event));\n\t\t\t\t// note that all files are pending transformation\n\t\t\t\tawait Promise.all(\n\t\t\t\t\t(\n\t\t\t\t\t\tawait watcher.init()\n\t\t\t\t\t).map(async (file) => {\n\t\t\t\t\t\tconst { path } = file;\n\t\t\t\t\t\tif (watcher.pre) {\n\t\t\t\t\t\t\tawait watcher.pre(file);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.paths.add(file.path);\n\t\t\t\t\t\tthis._active.add(file.path);\n\t\t\t\t\t\tfiles.push([watcher, path, file]);\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t\tfor (const generator of this._generators) {\n\t\t\tthis._active.add(generator);\n\t\t}\n\t\t// process each physical file\n\t\tfor (const [watcher, path, file] of files) {\n\t\t\tthis._process_physical_file(watcher, path, file);\n\t\t}\n\t\t// process each generator\n\t\tfor (const generator of this._generators) {\n\t\t\tthis._process_generator(generator);\n\t\t}\n\t\t// wait and finish up\n\t\tawait done;\n\t\tthis._status = Status.After;\n\t\tthis._is_processing = false;\n\t\tif (this._watchers.some((watcher) => watcher.watch)) {\n\t\t\tthis._enqueue();\n\t\t}\n\t}\n\n\t// wait for a file to be available and retrieve it, marking dependencies as appropriate\n\tasync get(path: string): Promise<File>;\n\tasync get(paths: string[]): Promise<File[]>;\n\tasync get(filter: Filter): Promise<File[]>;\n\tasync get(_: any): Promise<any> {\n\t\tif (typeof _ === 'string') {\n\t\t\t_ = this.resolve(_);\n\t\t}\n\t\tif (Array.isArray(_)) {\n\t\t\treturn Promise.all(_.map((path) => this.get(path)));\n\t\t}\n\t\tif (typeof _ !== 'string' && typeof _ !== 'function') {\n\t\t\tthrow new TypeError('defiler.get: argument must be a string, an array, or a function');\n\t\t}\n\t\tconst current = this._context.getStore();\n\t\tif (current) {\n\t\t\tthis._deps.push([current, _]);\n\t\t}\n\t\tif (this._status === Status.During && current && (typeof _ === 'function' || !this.files.has(_))) {\n\t\t\tif (this._when_found.has(_)) {\n\t\t\t\tconst { promise, paths } = this._when_found.get(_);\n\t\t\t\tpaths.push(current);\n\t\t\t\tthis._check_wave();\n\t\t\t\tawait promise;\n\t\t\t} else {\n\t\t\t\tlet resolve;\n\t\t\t\tconst promise = new Promise<void>((res) => (resolve = res));\n\t\t\t\tthis._when_found.set(_, { promise, resolve, paths: [current] });\n\t\t\t\tthis._check_wave();\n\t\t\t\tawait promise;\n\t\t\t}\n\t\t}\n\t\treturn typeof _ === 'function' ? this.get([...this.files.keys()].filter(_).sort()) : this.files.get(_);\n\t}\n\n\t// add a new virtual file\n\tadd(file: FileData): Promise<void> {\n\t\tif (this._status === Status.Before) {\n\t\t\tthrow new Error('defiler.add: cannot call before calling exec');\n\t\t}\n\t\tif (typeof file !== 'object') {\n\t\t\tthrow new TypeError('defiler.add: file must be an object');\n\t\t}\n\t\tfile.path = this.resolve(file.path);\n\t\tthis._orig_data.set(file.path, file);\n\t\treturn this._process_file(file, 'add');\n\t}\n\n\t// resolve a given path from the file currently being transformed\n\tresolve(path: string): string {\n\t\tif (this._resolver) {\n\t\t\tconst current = this._context.getStore();\n\t\t\tif (typeof current === 'string') {\n\t\t\t\treturn this._resolver(current, path);\n\t\t\t}\n\t\t}\n\t\treturn path;\n\t}\n\n\t// private methods\n\n\t// return a Promise that we will resolve at the end of this wave, and save its resolver\n\tprivate _start_wave(): Promise<void> {\n\t\treturn new Promise((res) => (this._end_wave = res));\n\t}\n\n\t// add a Watcher event to the queue, and handle queued events\n\tprivate async _enqueue(watcher?: WatcherData, event?: WatcherEvent): Promise<void> {\n\t\tif (event) {\n\t\t\tthis._queue.push([watcher, event]);\n\t\t}\n\t\tif (this._is_processing) {\n\t\t\treturn;\n\t\t}\n\t\tthis._is_processing = true;\n\t\twhile (this._queue.length) {\n\t\t\tconst done = this._start_wave();\n\t\t\tconst [watcher, { event, path, stats }] = this._queue.shift();\n\t\t\tconst file = { path, stats };\n\t\t\tif (watcher.pre) {\n\t\t\t\tawait watcher.pre(file);\n\t\t\t}\n\t\t\tif (event === '+') {\n\t\t\t\tthis._process_physical_file(watcher, path, file);\n\t\t\t} else if (event === '-') {\n\t\t\t\tconst { path } = file;\n\t\t\t\tconst old_file = this.files.get(path);\n\t\t\t\tthis.paths.delete(path);\n\t\t\t\tthis._orig_data.delete(path);\n\t\t\t\tthis.files.delete(path);\n\t\t\t\tawait this._call_transform(old_file, 'delete');\n\t\t\t\tthis._process_dependents(path);\n\t\t\t}\n\t\t\tawait done;\n\t\t}\n\t\tthis._is_processing = false;\n\t}\n\n\t// create a file object for a physical file and process it\n\tprivate async _process_physical_file({ dir, read, enc }: WatcherData, path: string, file: FileData): Promise<void> {\n\t\tif (typeof read === 'function') {\n\t\t\tread = await read({ path, stats: file.stats });\n\t\t}\n\t\tif (read) {\n\t\t\tfile.bytes = await fs.promises.readFile(dir + '/' + path);\n\t\t}\n\t\tif (typeof enc === 'function') {\n\t\t\tenc = await enc({ path, stats: file.stats, bytes: file.bytes });\n\t\t}\n\t\tfile.enc = enc;\n\t\tthis.paths.add(file.path);\n\t\tthis._orig_data.set(file.path, file);\n\t\tawait this._process_file(file, 'read');\n\t}\n\n\t// transform a file, store it, and process dependents\n\tprivate async _process_file(data: FileData, event: string): Promise<void> {\n\t\tconst file: File = Object.assign(new File(), data);\n\t\tconst { path } = file;\n\t\tthis._active.add(path);\n\t\tawait this._call_transform(file, event);\n\t\tthis.files.set(path, file);\n\t\tif (this._status === Status.During) {\n\t\t\tthis._mark_found(path);\n\t\t} else {\n\t\t\tthis._process_dependents(path);\n\t\t}\n\t\tthis._active.delete(path);\n\t\tthis._check_wave();\n\t}\n\n\t// call the transform on a file with the given event string, and handle errors\n\tprivate async _call_transform(file: File, event: string): Promise<void> {\n\t\ttry {\n\t\t\tawait this._context.run(file.path, () => this._transform({ file, event }));\n\t\t} catch (error) {\n\t\t\tif (this._onerror) {\n\t\t\t\tthis._onerror({ file, event, error });\n\t\t\t}\n\t\t}\n\t}\n\n\t// run the generator given by the symbol\n\tprivate async _process_generator(generator: Generator): Promise<void> {\n\t\tthis._active.add(generator);\n\t\ttry {\n\t\t\tawait this._context.run(generator, generator);\n\t\t} catch (error) {\n\t\t\tif (this._onerror) {\n\t\t\t\tthis._onerror({ generator, error });\n\t\t\t}\n\t\t}\n\t\tthis._active.delete(generator);\n\t\tthis._check_wave();\n\t}\n\n\t// re-process all files that depend on a particular path\n\tprivate _process_dependents(path: string): void {\n\t\tconst dependents = new Set<Name>();\n\t\tfor (const [dependent, dependency] of this._deps) {\n\t\t\tif (typeof dependency === 'string' ? dependency === path : dependency(path)) {\n\t\t\t\tdependents.add(dependent);\n\t\t\t}\n\t\t}\n\t\tthis._deps = this._deps.filter(([dependent]) => !dependents.has(dependent));\n\t\tfor (const dependent of dependents) {\n\t\t\tif (typeof dependent === 'function') {\n\t\t\t\tthis._process_generator(dependent);\n\t\t\t} else if (this._orig_data.has(dependent)) {\n\t\t\t\tthis._process_file(this._orig_data.get(dependent), 'retransform');\n\t\t\t}\n\t\t}\n\t\tthis._check_wave();\n\t}\n\n\t// check whether this wave is complete, and, if not, whether we need to break a deadlock\n\tprivate _check_wave(): void {\n\t\tif (!this._active.size) {\n\t\t\tthis._end_wave();\n\t\t} else if (this._status === Status.During) {\n\t\t\tconst filter_waiting = new Set<Name>();\n\t\t\tconst all_waiting = new Set<Name>();\n\t\t\tfor (const [path, { paths }] of this._when_found) {\n\t\t\t\tif (typeof path === 'function' || this._active.has(path)) {\n\t\t\t\t\tpaths.forEach((path) => filter_waiting.add(path));\n\t\t\t\t}\n\t\t\t\tpaths.forEach((path) => all_waiting.add(path));\n\t\t\t}\n\t\t\tif ([...this._active].every((path) => filter_waiting.has(path))) {\n\t\t\t\t// all pending files are currently waiting for a filter or another pending file\n\t\t\t\t// break deadlock: assume all filters have found all they're going to find\n\t\t\t\tfor (const path of this._when_found.keys()) {\n\t\t\t\t\tif (typeof path === 'function') {\n\t\t\t\t\t\tthis._mark_found(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ([...this._active].every((path) => all_waiting.has(path))) {\n\t\t\t\t// all pending files are currently waiting for one or more other files to exist\n\t\t\t\t// break deadlock: assume all files that have not appeared yet will never do so\n\t\t\t\tfor (const path of this._when_found.keys()) {\n\t\t\t\t\tif (typeof path === 'string' && !this._active.has(path)) {\n\t\t\t\t\t\tthis._mark_found(path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// mark a given awaited file as being found\n\tprivate _mark_found(path: string | Filter): void {\n\t\tif (this._when_found.has(path)) {\n\t\t\tthis._when_found.get(path).resolve();\n\t\t\tthis._when_found.delete(path);\n\t\t}\n\t}\n}\n\ninterface DefilerData {\n\ttransform: Transform;\n\tgenerators?: Generator[];\n\tresolver?: Resolver;\n\tonerror?: OnError;\n}\n\ninterface FileData {\n\tpath: string;\n\t[prop: string]: any;\n}\n\ninterface Filter {\n\t(path: string): boolean;\n}\n\ninterface Generator {\n\t(): Promise<void>;\n}\n\ntype Name = string | Generator;\n\ninterface OnError {\n\t(arg: { file?: any; event?: string; generator?: Generator; error: Error }): void;\n}\n\ninterface Resolver {\n\t(base: string, path: string): string;\n}\n\nconst enum Status {\n\tBefore,\n\tDuring,\n\tAfter,\n}\n\ninterface Transform {\n\t(arg: { file: File; event: string }): Promise<void>;\n}\n\ninterface WatcherData extends Watcher {\n\tread: boolean | ((arg: { path: string; stats: fs.Stats }) => Promise<boolean>);\n\tenc: string | ((arg: { path: string; stats: fs.Stats; bytes: Buffer }) => Promise<string>);\n\tpre: (data: FileData) => Promise<void>;\n}\n\ninterface WhenFound {\n\tpromise: Promise<void>;\n\tresolve: () => void;\n\tpaths: Name[];\n}\n"],"names":["EventEmitter","AsyncLocalStorage","resolve"],"mappings":"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"}